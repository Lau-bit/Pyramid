<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Julia Explorer</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; touch-action:none; }
    canvas { display:block; }
  </style>
</head>
<body>
  <canvas id="glcanvas"></canvas>

  <script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
  </script>

  <script id="fragment-shader" type="x-shader/x-fragment">
    precision highp float;
    uniform vec2 u_resolution;
    uniform vec2 u_zoomCenter;
    uniform float u_zoomSize;
    uniform vec2 u_juliaParam;
    uniform float u_time;
    uniform int u_maxIterations;

    vec3 palette(float t) {
      vec3 a = vec3(0.5,0.5,0.5);
      vec3 b = vec3(0.5,0.5,0.5);
      vec3 c = vec3(1.0,1.0,1.0);
      vec3 d = vec3(0.263,0.416,0.557);
      return a + b*cos(6.28318*(c*t + d + u_time*0.1));
    }

    void main() {
      vec2 uv = (gl_FragCoord.xy - u_resolution*0.5) / min(u_resolution.x, u_resolution.y);
      uv = uv * u_zoomSize + u_zoomCenter;

      vec2 c = u_juliaParam + uv * 1.5;
      vec2 z = uv;
      int i = 0;

      for(int iter=0; iter<1024; iter++) {
        if(i >= u_maxIterations) break;
        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
        if(dot(z,z) > 64.0) break;
        i++;
      }

      if(i == u_maxIterations) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
      } else {
        float sn = float(i) - log(log(dot(z,z))/log(64.0))/log(2.0);
        vec3 col = palette(sn/float(u_maxIterations) + u_time*0.05);
        col = pow(col, vec3(0.82));
        gl_FragColor = vec4(col, 1.0);
      }
    }
  </script>

  <script>
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true }) ||
               canvas.getContext('experimental-webgl', { preserveDrawingBuffer: true });

    if (!gl) {
      alert("WebGL not supported");
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    function createShader(type, source) {
      const s = gl.createShader(type);
      gl.shaderSource(s, source);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(s));
        gl.deleteShader(s);
        return null;
      }
      return s;
    }

    const vs = createShader(gl.VERTEX_SHADER, document.getElementById('vertex-shader').text);
    const fs = createShader(gl.FRAGMENT_SHADER, document.getElementById('fragment-shader').text);
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    gl.useProgram(prog);

    const posLoc = gl.getAttribLocation(prog, 'a_position');
    const quad = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quad);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    const uRes   = gl.getUniformLocation(prog, 'u_resolution');
    const uCen   = gl.getUniformLocation(prog, 'u_zoomCenter');
    const uSize  = gl.getUniformLocation(prog, 'u_zoomSize');
    const uJulia = gl.getUniformLocation(prog, 'u_juliaParam');
    const uTime  = gl.getUniformLocation(prog, 'u_time');
    const uIter  = gl.getUniformLocation(prog, 'u_maxIterations');

    let zoomCenter = [0, 0];
    let zoomSize   = 4.0;
    let isDragging = false;
    let dragStart  = [0, 0];

    // Freeze state (right-click freezes animation)
    let isFrozen = false;
    let frozenTime = 0;
    let frozenJulia = [-0.7269, 0.1889];

    const startTime = Date.now();

    // Right-click: Freeze / Unfreeze (no visual feedback)
    canvas.addEventListener('contextmenu', e => {
      e.preventDefault();
      isFrozen = !isFrozen;

      if (isFrozen) {
        frozenTime = (Date.now() - startTime) / 1000;
        frozenJulia = [
          -0.7269 + Math.sin(frozenTime * 0.3) * 0.2,
          0.1889 + Math.cos(frozenTime * 0.37) * 0.2
        ];
      }
    });

    // Mouse drag → pan
    canvas.addEventListener('mousedown', e => {
      if (e.button === 0) {
        isDragging = true;
        dragStart = [e.clientX, e.clientY];
      }
    });
    canvas.addEventListener('mousemove', e => {
      if (isDragging) {
        const dx = (e.clientX - dragStart[0]) / canvas.width  * zoomSize * 4;
        const dy = (e.clientY - dragStart[1]) / canvas.height * zoomSize * 4;
        zoomCenter[0] -= dx;
        zoomCenter[1] += dy;
        dragStart = [e.clientX, e.clientY];
      }
    });
    canvas.addEventListener('mouseup',   () => isDragging = false);
    canvas.addEventListener('mouseleave',() => isDragging = false);

    // Wheel → zoom
    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const factor = Math.pow(1.005, -e.deltaY);
      const aspectX = canvas.width  < canvas.height ? canvas.width  / canvas.height : 1;
      const aspectY = canvas.width  > canvas.height ? canvas.height / canvas.width  : 1;
      const mx = (e.clientX / canvas.width  - 0.5) * zoomSize * aspectX;
      const my = (e.clientY / canvas.height - 0.5) * zoomSize * aspectY;

      zoomCenter[0] += mx * (1 - factor);
      zoomCenter[1] += my * (1 - factor);
      zoomSize *= factor;
      zoomSize = Math.max(zoomSize, 1e-15);
    }, {passive:false});

    // Touch support (pan)
    canvas.addEventListener('touchstart', e => {
      if (e.touches.length === 1) {
        const t = e.touches[0];
        dragStart = [t.clientX, t.clientY];
        isDragging = true;
      }
    }, {passive:false});

    canvas.addEventListener('touchmove', e => {
      if (e.touches.length === 1) {
        const t = e.touches[0];
        const dx = (t.clientX - dragStart[0]) / canvas.width  * zoomSize * 4;
        const dy = (t.clientY - dragStart[1]) / canvas.height * zoomSize * 4;
        zoomCenter[0] -= dx;
        zoomCenter[1] += dy;
        dragStart = [t.clientX, t.clientY];
        e.preventDefault();
      }
    }, {passive:false});

    canvas.addEventListener('touchend', () => isDragging = false);

    // Render loop
    function render() {
      const t = isFrozen ? frozenTime : (Date.now() - startTime) / 1000;

      gl.uniform2f(uRes, canvas.width, canvas.height);
      gl.uniform2fv(uCen, zoomCenter);
      gl.uniform1f(uSize, zoomSize);

      const juliaX = isFrozen ? frozenJulia[0] : -0.7269 + Math.sin(t * 0.3) * 0.2;
      const juliaY = isFrozen ? frozenJulia[1] :  0.1889 + Math.cos(t * 0.37) * 0.2;

      gl.uniform2f(uJulia, juliaX, juliaY);
      gl.uniform1f(uTime, t);
      gl.uniform1i(uIter, Math.min(512, Math.floor(50 + 380 / Math.sqrt(zoomSize))));

      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }

    render();
  </script>
</body>
</html>